const CSON = require('cson-parser');
const fs = require('fs');
import Rule, { RuleDefinition } from '../src/rule';
import Config, { BaseLocationConfig, Point, LocationConfig } from './lttp-config';

// Anything writable, don't care beyond it implements this type
interface Writable {
  write: (s: string) => void;
}

/**
 * Utility to get coordinates from a location. Coordinates are an array of two
 * numbers, this makes sure they exist like that and then returns them as a
 * string, ready to be output into the final JavaScript file.
 */
function getCoords(location: BaseLocationConfig): string {
  let coords: Point | null = null;
  if ('location' in location) {
    coords = location['location'];
    if (Array.isArray(coords) && coords.length === 2) {
      return `${coords[0]}, ${coords[1]}`;
    } else {
      console.error(`Bad coordinates ${coords} for location`);
    }
  }
  return 'null, null';
}

function parseFile(filename: string, output: Writable): void {
  parse(fs.readFileSync(filename, { encoding: 'utf8' }), output);
}

function parse(data: string | Config, output: Writable): void {
  // A pattern frequently used within this function is parsing a rule but not
  // using the result. This is to let the rule "fail fast": fail before it gets
  // a chance to be output.
  if (typeof data === 'string')
    data = CSON.parse(data) as Config;
  output.write(`// THIS IS A MACHINE GENERATED FILE
// Do not edit this file directly.

"use strict";

import Rule from './rule';
import Item from './item';
import Location from './location';
import Region from './region';
import Dungeon from './dungeon';

export function createDefaultDatabase() {
  let rules = {
`);
  let rules = data.rules;
  for (let id in rules) {
    let rule = rules[id];
    if ('requires' in rule) {
      // Make sure the rule works.
      Rule.parse(rule.requires);
      output.write(`    ${JSON.stringify(id)}: Rule.parse(${JSON.stringify(rule['requires'])}),\n`);
    } else {
      throw new Error(`Missing requires in rule ${id}: rule must have some requirement.`);
    }
  }
  output.write(`
  };
  let regions = [
`);
  let regions = data['regions'];
  for (let id in regions) {
    let region = regions[id], requires: RuleDefinition = true;
    let name = region.name;
    if (!name)
      name = 'Unknown';
    if ('requires' in region) {
      requires = region.requires;
      // Make sure the rule works.
      Rule.parse(requires);
    }
    output.write(`    new Region(${JSON.stringify(id)}, ${JSON.stringify(name)}, ${JSON.stringify(requires)}),\n`);
  }
  output.write('\n  ];\n  let items = [\n');
  let items = data.items;
  for (let id in items) {
    let item = items[id];
    let name = item.name;
    if (!name)
      name = 'Unknown';
    output.write(`    new Item(${JSON.stringify(id)}, ${JSON.stringify(name)}),\n`);
  }
  output.write(`\n  ];\n  let locations = {\n`);
  let locations = data['locations'], mergeLocations: Record<string, LocationConfig> = {};
  for (let id in locations) {
    let location = locations[id];
    if ('merge' in location) {
      // This is a "merge location" and not a "real" location. Can't be dumped
      // yet but will instead be generated later.
      mergeLocations[id] = location;
    } else {
      let name = location['name'];
      if (!name)
        name = 'Unknown';
      // By default locations are available and not visible.
      let requires: RuleDefinition = true,
        visible: RuleDefinition = false,
        items = 1,
        type = 'item';
      if ('requires' in location) {
        requires = location['requires'];
        Rule.parse(requires);
      }
      if ('visible' in location) {
        visible = location['visible'];
        Rule.parse(visible);
      }
      if ('items' in location) {
        items = location['items'];
      }
      if ('type' in location) {
        type = location['type'];
        if (type !== 'item') {
          items = 0;
        }
      }
      output.write(`    ${JSON.stringify(id)}: new Location(${JSON.stringify(id)}, ${JSON.stringify(name)}, ${JSON.stringify(requires)}, ${JSON.stringify(visible)}, ${getCoords(location)}, ${JSON.stringify(items)}`);
      if (type !== 'item') {
        output.write(`, ${JSON.stringify(type)}`);
      }
      output.write('),\n');
    }
  }
  output.write('\n  };');
  for (let id in mergeLocations) {
    let location = mergeLocations[id];
    let name = location['name'];
    if (!name)
      name = 'Unknown';
    output.write(`\n  locations[${JSON.stringify(id)}] = Location.merge(${JSON.stringify(id)}, ${JSON.stringify(name)}, ${getCoords(location)}, [`);
    for (let subLocation of location['merge']) {
      output.write(`locations[${JSON.stringify(subLocation)}],\n`);
    }
    output.write(']);');
  }
  output.write(`\n  let dungeons = [\n`);
  let dungeons = data['dungeons'];
  for (let id in dungeons) {
    let dungeon = dungeons[id], keys = 0;
    let name = dungeon['name'];
    if (!name)
      name = 'Unknown';
    // By default dungeons can be entered, although this only applies to one.
    let enter: RuleDefinition = true;
    if ('enter' in dungeon) {
      enter = dungeon['enter'];
      Rule.parse(enter);
    }
    if ('keys' in dungeon) {
      keys = dungeon['keys'];
    }
    // Pre-stringify a bunch of stuff that'll be inserted into JS code:
    id = JSON.stringify(id);
    name = JSON.stringify(name);
    let enterJson = JSON.stringify(enter);
    output.write(`    new Dungeon(${id}, ${name}, ${enterJson}, `);
    // Boss definition
    if ('boss' in dungeon) {
      const boss = dungeon['boss'];
      let access: RuleDefinition = true,
        defeat: RuleDefinition = true,
        prize: RuleDefinition = true;
      name = 'Unspecified';
      if (typeof boss === 'string') {
        name = boss;
      } else if (typeof boss === 'object') {
        if ('name' in boss) {
          name = boss['name'];
          if (typeof name !== 'string')
            throw new Error("Invalid name for boss: " + JSON.stringify(name));
        }
        if ('defeat' in boss) {
          defeat = boss['defeat'];
          Rule.parse(defeat);
        }
        if ('access' in boss) {
          access = boss['access'];
          Rule.parse(access);
        }
        if ('prize' in boss) {
          prize = boss['prize'];
        }
      } else {
        throw new Error("Invalid boss definition " + JSON.stringify(boss));
      }
      output.write(`new Dungeon.Boss(${JSON.stringify(name)}, ${JSON.stringify(defeat)}, ${JSON.stringify(access)}`);
      if (!prize) {
        output.write(', false');
      }
      output.write('), ');
    } else {
      // Otherwise, no boss. (True for Hyrule Castle Escape and nowhere else.)
      output.write('null, ');
    }
    // Items definition
    if ('items' in dungeon) {
      let items = dungeon['items'], subcomma = false;
      output.write('[');
      items.forEach(item => {
        let name = 'Some Chest', type = 'chest', access: RuleDefinition = true;
        if (typeof item === 'string') {
          name = item;
        } else if (typeof item === 'object') {
          if ('name' in item) {
            name = item['name'];
            if (typeof name !== 'string')
              throw new Error("Invalid name for item: " + JSON.stringify(name));
          }
          if ('type' in item) {
            type = item['type'];
            if (typeof type !== 'string')
              throw new Error("Invalid type for item: " + JSON.stringify(type));
            if (type === 'dash') {
              // Default access for dash is just 'pegasus_boots'
              access = 'pegasus_boots';
            }
          }
          if ('access' in item) {
            access = item['access'];
            Rule.parse(access);
          }
        } else {
          throw new Error("Invalid item definition " + JSON.stringify(item));
        }
        if (subcomma) {
          output.write(',');
        } else {
          subcomma = true;
        }
        name = JSON.stringify(name);
        access = JSON.stringify(access);
        type = JSON.stringify(type);
        output.write(`\n      new Dungeon.ItemLocation(${name}, ${access}, ${type})`);
      });
      output.write(']');
    } else {
      // No items.
      output.write('[]');
    }
    output.write(`, ${JSON.stringify(keys)}, ${getCoords(dungeon)}`);
    if ('notInPool' in dungeon) {
      // Some dungeons exclude dungeon items
      let notInPool = dungeon['notInPool'];
      if (typeof notInPool === 'string') {
        notInPool = [ notInPool ];
      }
      if (!Array.isArray(notInPool)) {
        throw new Error("Invalid notInPool value: " + JSON.stringify(notInPool));
      }
      for (let missing of notInPool) {
        if (typeof missing !== 'string') {
          throw new Error("Invalid notInPool value: " + JSON.stringify(missing));
        }
      }
      output.write(', ' + JSON.stringify(notInPool));
    } else if ('medallion' in dungeon) {
      // Have to include this entry in this case.
      output.write(', null');
    }
    if ('medallion' in dungeon) {
      let medallion = dungeon['medallion'];
      if (typeof medallion !== 'string')
        throw new Error("Invalid medallion value: " + JSON.stringify(medallion));
      output.write(`, ${JSON.stringify(medallion)}`);
    }
    output.write('),\n');
  }
  // For slot, prize, layout information, and defaults, just paste it through.
  let defaults = data['defaults'];
  if (typeof defaults === 'string') {
    defaults = [ defaults ];
  } else if (!Array.isArray(defaults)) {
    defaults = [];
  }
  output.write(`
  ];
  return {
    rules: rules, items: items, regions: regions, locations: locations,
    dungeons: dungeons,
    slots: ${JSON.stringify(data['slots'])},
    prizes: ${JSON.stringify(data['prizes'])},
    layout: ${JSON.stringify(data['layout'])},
    defaults: ${JSON.stringify(defaults)}
  };
}

`);
  // Now deal with logics.
  output.write('export let LOGICS = {\n');
  let genericLogic = null;
  for (let id in data.logics) {
    if (genericLogic === null) {
      genericLogic = id;
    }
    let logic = data.logics[id];
    let name = id[0].toUpperCase() + id.substring(1);
    if ('name' in logic)
      name = logic.name;
    output.write(`  ${JSON.stringify(id)}: ${JSON.stringify(name)},\n`);
  }
  output.write(`
};

export let DEFAULT_LOGIC = ${JSON.stringify(genericLogic)};

export default function createDatabase(logic) {
  let db = createDefaultDatabase();
  if (!logic) {
    return db;
  }
  switch(logic) {
`);
  for (let id in data.logics) {
    let logic = data.logics[id];
    output.write(`  case ${JSON.stringify(id)}:\n`);
    if (logic.rules) {
      for (let rID in logic.rules) {
        let rule = logic.rules[rID];
        if (!('requires' in rule))
          throw new Error(`Missing requires in rule override ${rID} in logic ${id}`);
        Rule.parse(rule.requires);
        output.write(`    db.rules[${JSON.stringify(rID)}] = Rule.parse(${JSON.stringify(rule.requires)});\n`);
      }
    }
    if (logic.slots) {
      // Slots are basically a pure pass-through.
      for (let sID in logic.slots) {
        output.write(`    db.slots[${JSON.stringify(sID)}] = ${JSON.stringify(logic.slots[sID])};\n`);
      }
    }
    output.write('    break;\n');
  }
  output.write(`  default:
    throw new Error('Unknown logic ' + logic);
  }
  db.logic = logic;
  return db;
}
`);
}

exports.parseFile = parseFile;
exports.parse = parse;

class StringWriter {
  contents = "";
  write(s: string): void {
    this.contents += s;
  }
  toString(): string {
    return this.contents;
  }
}

exports.parseToString = function(data: string | Config): string {
  const s = new StringWriter();
  parse(data, s);
  return s.toString();
};

if (module.parent === null) {
  if (process.argv.length >= 3) {
    let out = process.stdout;
    if (process.argv.length >= 4) {
      out = fs.createWriteStream(process.argv[3]);
    }
    try {
      parseFile(process.argv[2], out);
    } catch (ex) {
      console.error('Unable to generate file:');
      console.error(ex.toString());
    }
  }
}